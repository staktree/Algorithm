/*
https://www.acmicpc.net/problem/1676
BOJ 1676번 팩토리얼 0의 개수

(1) 접근
N!을 계산한 뒤, 맨 뒤에서부터 0의 개수를 세는 문제이다.
하지만 N의 범위가 1 ~ 500이므로, 500!을 계산하면 int형의 오버플로우가 발생한다. 그래서 다른 방법으로 접근해야한다. 
N!에서 5와 2의 개수를 세는 방법으로 문제를 해결했다. 5 x 2가 1개 있을 때마다 0이 하나씩 생성된다. 또한, 팩토리얼의 특성 상 N까지의 수의 절반은 짝수이다. 따라서 2가 5보다 무조건 많기 때문에 5의 개수만 세면 된다.

(2) 해결
N에 대해서 5를 나눈 몫과 25를 나눈 몫, 125를 나눈 몫을 모두 더하면 된다.(500보다 작은 5의 배수)
5를 제외한 수를 나눈 몫을 더하는 이유는 25를 예로 들어 설명하자면,
25의 경우 5 x 5이기 때문에 5로 나누면 1개만 카운팅된다. 그래서 25를 한번 더 나누어 세지 않은 5를 체크한다.
*/
#include <iostream>
#include <cstdio>

using namespace std;

int N;
int ans = 0;

int main()
{
	cin >> N;
	int five = 5;
	while (N >= five)
	{
		ans += N / five;
		five *= 5;
	}
	cout << ans;
	return 0;
} 